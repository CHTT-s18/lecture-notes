\documentclass{article} \usepackage{chtt-notes} \usepackage{stmaryrd}
\usepackage{amssymb}

\usetikzlibrary{arrows}

\scribes{Paul G\"olz}
\week{16}
% The following command will let you cross-reference labels in the
% files week1.tex, week2.tex, \ldots, week\@week.tex, where if l is a
% label in ``weekN.tex'', then you can access the label using
% \cref{WN:l}.
\doXRs

% General remark: Using \cref{label} will fill in the appropriate
% environment name. For example, ``\begin{lemma}\label{lem:foo}
%   ...\end{lemma} By \cref{lem:foo}'' will produce ``Lemma 15 ... By
% lemma~15''

\renewcommand{\bool}{\mathsf{Bool}}
\newcommand{\wbool}{\mathsf{wBool}}
\newcommand{\hcom}{\mathsf{hcom}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\coe}{\mathsf{coe}}
\newcommand{\ival}[1]{#1~\mathsf{val}}
\newcommand{\itype}[1]{#1~\mathsf{type}}
\newcommand{\di}[1]{\;[#1]}
\newcommand{\ps}{\di{\Psi}}
\newcommand{\T}{\mathsf{tt}}
\newcommand{\F}{\mathsf{ff}}
\newcommand{\If}{\mathsf{if}}
\newcommand{\hcomr}{(M; \overrightarrow{\xi_i \hookrightarrow y. \; N_i})}
\newcommand{\fst}{\mathsf{fst}}
\newcommand{\snd}{\mathsf{snd}}
\newcommand{\Path}{\mathsf{Path}}

\begin{document}
\maketitle

\section{Defining Kan composition $\hcom_A$ for various types $A$}
\subsection{The strict Booleans $\bool$}
\marginpar{May 1, 2018}
The strict Booleans serve as the type of observables in our system, and they will be used to prove canonicity.
They are defined as follows:
\[ \ival{\bool}_{\Psi} \qquad \itype{\bool \doteq \bool} \ps \]
\[ \ival{\T}_{\Psi} \qquad \ival{\F}_{\Psi} \qquad \T \doteq \T \in \bool \ps \qquad \F \doteq \F \in \bool \ps \]
\[ \inferrule{M \mapsto_{\Psi} M'}{\If(M; M_0; M_1) \mapsto_{\Psi} \If(M'; M_0; M_1)} \qquad \inferrule{ }{\If(\T; M_0; M_1) \mapsto_{\Psi} M_0} \qquad \inferrule{ }{\If(\F; M_0; M_1) \mapsto_{\Psi} M_1} \]
All lines in $\bool$ are degenerate; each strict Boolean is $\T$ or $\F$. Therefore, both coercion and composition are trivial:
\[ \coe^{r \leadsto r'}_{\_.\bool}(M) \mapsto M \qquad \hcom^{r \leadsto r'}_{Bool}(M; \overrightarrow{\xi_i \hookrightarrow y. \; N_i}) \mapsto M\]
One can check that this defines a valid Kan structure.

\subsection{The weak Booleans $\wbool$}
For the strict Booleans, we manually encoded the insight that there are only two Booleans.
We will now explore the weak Booleans, that are defined as the equivalent to an inductive type, namely as the free~(think: ``least'') Kan type generated by $\T$ and $\F$.
We begin as above:
\[ \ival{\wbool}_{\Psi} \qquad \itype{\wbool \doteq \wbool} \ps \]
\[ \ival{\T}_{\Psi} \qquad \ival{\F}_{\Psi} \qquad \T \doteq \T \in \wbool \ps \qquad \F \doteq \F \in \wbool \ps \]
However, instead of our specialized composition above, we simply declare $\hcom$'s to be values:\footnote{For technical reasons, the $\hcom$ actually steps to an $\mathsf{fcom}$ value as seen last week. We will ignore this complication for pedagogical reasons.}
\[ \inferrule{\text{no $\xi_i$ is true} \and r \neq r'}{\ival{\hcom^{r \leadsto r'}_{\wbool}\hcomr}_{\Psi}} \]

As a result, we now have infinitely many Booleans! In particular, this poses the question of how $\If$ should be evaluated if its first argument is an $\hcom$:
Let us say that we have $M_0 \in A[\T / a] \ps$, $M_1 \in A[\F/a] \ps$ and $a : \wbool \gg \itype{A}$; thus, 
\[\If_{a.A}(\hcom_{\wbool}^{r \leadsto r'}\hcomr; M_0; M_1) \in A[\hcom_{\wbool}^{r \leadsto r'}\hcomr/a] \ps.\]
But where should this expression step? Even though this problem is reminiscent of the problems that prevent HoTT from having computational meaning, our problem can be solved.
The main idea is to ``push the composition out'' of the conditional.

Set $M' \coloneqq \If_{a.A}(M; M_0; M_1) \in A[M]$ and $N_i \coloneqq \If_{a.A}(N_i; M_0; M_1) \in A[N_i]$.
We might want to compose these terms as $\hcom_{?}^{r \leadsto r'}(M'; \overrightarrow{\xi_i \hookrightarrow y.\; N_i'})$, but it is not clear which type we should choose for $?$.
The resulting type should be $A[\hcom_{\wbool}^{r \leadsto r'}\hcomr/a]$, but we cannot use this for $?$ because then the types of $M'$ and $N_i'$ would not match.
The solution is to use a heterogeneous composition, i.e.,
\[ \If_{a.A}(\hcom_{\wbool}^{r \leadsto r'}\hcomr; M_0; M_1) \mapsto \com_{z.A[\mathit{zline} / a]}^{r \leadsto r'}(M'; \overrightarrow{\xi_i \hookrightarrow y.\; N_i'}). \]
It remains to choose $\mathit{zline}$ such that $\mathit(zline)$ equals $M$ at $z = r$ and equals $\hcom_{\wbool}^{r \leadsto r'}\hcomr$ at $z = r'$.
Choosing $\mathit{zline}$ as $\hcom_{\wbool^{r \leadsto z}}\hcomr$ works.

It is worth pointing out that the motive $a.A$ of the conditional cannot be erased for evaluation: If we unfold the definition of $\com$, we rely on coercions that are governed by the type family $A$.

\subsection{Pi types}
For Pi types, defining $\hcom$ works without complications:
\[ \hcom_{a : A \to B(a)}^{r \leadsto r'}\hcomr \mapsto \lambda a. \; \hcom_{B(a)}^{r \leadsto r'}(M(a); \overrightarrow{\xi_i \hookrightarrow y.\;N_i(a)}) \]

\subsection{Sigma types}
For Sigma types, dependency slightly complicates the picture, by requiring a heterogeneous composition for the second component:
\begin{align*}
    \hcom_{a:A \times B(a)}^{r \leadsto r'}&\hcomr \\
    \mapsto \langle &\hcom_{A}^{r \leadsto r'}(\fst(M); \overrightarrow{\xi_i \hookrightarrow y.\;\fst(N_i)}), \\
    &\com_{z. B[ \hcom_{A}^{r \leadsto z}(\fst(M); \overrightarrow{\xi_i \hookrightarrow y.\;\fst(N_i)}) /a]}^{r \leadsto r'}(\snd(M); \overrightarrow{\xi_i \hookrightarrow y.\; \snd(N_i)}) \rangle
\end{align*}

\subsection{Path types}
\marginpar{May 3, 2018}
Where should $\hcom_{\Path[z.A](P_0; P_1)}^{r \leadsto r'}\hcomr$ step to?
$M$, $N_0$ and $N_1$ are quoted lines and we can orient them in some direction $z$, as illustrated below for the two-dimensional case:
\begin{center}
\pgfmathsetmacro{\axoff}{-0.5}
\pgfmathsetmacro{\axlen}{-0.25}
\begin{minipage}{.2\textwidth}
\begin{tikzpicture}
[
  x = {(2.0cm , 0.0cm)} , 
  y = {(0.0cm , -2.0cm)} , 
  z = {(0cm , 0cm)}
]
  % axes
  \draw [->] (\axoff , 0 , 0) to node [left] {$y$} (\axoff , -\axlen , 0) ;
  \draw [->] (\axoff , 0 , 0) to node [auto] {$x$} ({\axoff - \axlen} , 0 , 0) ;
  % faces

  % vertices
  \node (000) at (0 , 0 , 0) {$\cdot$} ;
  \node (010) at (0 , 1 , 0) {$\cdot$} ;
  \node (100) at (1 , 0 , 0) {$\cdot$} ;
  \node (110) at (1 , 1 , 0) {$\cdot$} ;
  
  % edges
  % back
  \draw [-,draw=red,line width=1pt] (000) to (010) ;
  \draw [-,draw=blue,line width=1pt] (100) to (110) ;
  \draw [-,draw=green,line width=1pt] (000) to (100) ;
  \draw [-,dashed,line width=1pt] (010) to (110) ;

\node (N0) at (-.2, 0.5, 0) {$N_0$};
    \node (N1) at (1.2, 0.5, 0) {$N_1$};
    \node (M) at (0.5, 0.2, 0) {$M$} ;
\end{tikzpicture}
\end{minipage}
    \hspace{3cm}
\begin{minipage}{.2\textwidth}
\begin{tikzpicture}
[
  x = {(2.0cm , 0.0cm)} , 
  y = {(0.0cm , -2.0cm)} , 
  z = {(1cm , -0.7cm)}
]
  % axes
  \draw [->] (\axoff , 0 , 0) to node [below right] {$z$} (\axoff , 0 , -\axlen) ;
  \draw [->] (\axoff , 0 , 0) to node [left] {$y$} (\axoff , -\axlen , 0) ;
  \draw [->] (\axoff , 0 , 0) to node [auto] {$x$} ({\axoff - \axlen} , 0 , 0) ;
  % faces

  % vertices
  \node (000) at (0 , 0 , 0) {$\cdot$} ;
  \node (001) at (0 , 0 , 1) {$\cdot$} ;
  \node (010) at (0 , 1 , 0) {$\cdot$} ;
  \node (011) at (0 , 1 , 1) {$\cdot$} ;
  \node (100) at (1 , 0 , 0) {$\cdot$} ;
  \node (101) at (1 , 0 , 1) {$\cdot$} ;
  \node (110) at (1 , 1 , 0) {$\cdot$} ;
  \node (111) at (1 , 1 , 1) {$\cdot$} ;
  
  % edges
  % back
  \draw [-] (000) to (010) ;
  \draw [-] (100) to (110) ;
  \draw [-] (000) to (100) ;
  \draw [-] (010) to (110) ;
  % front
  \draw [-] (001) to (011) ;
  \draw [-] (101) to (111) ;
  \draw [-] (001) to (101) ;
  \draw [-] (011) to (111) ;
  % sides
  \draw [-] (000) to (001) ;
  \draw [-] (010) to (011) ;
  \draw [-] (100) to (101) ;
  \draw [-] (110) to (111) ;

  \draw [draw=none,fill=lightgray, opacity=0.5]
    (0,1,0) -- (1,1,0) -- (1,1,1) -- (0,1,1) -- cycle ;
  \draw [draw=none,fill=red, opacity=0.75]
    (0,0,0) -- (0,0,1) -- (0,1,1) -- (0,1,0) -- cycle ;
  \draw [draw=none,fill=blue, opacity=0.75]
    (1,0,0) -- (1,1,0) -- (1,1,1) -- (1,0,1) -- cycle ;
  \draw [draw=none,fill=green, opacity=0.75]
    (0,0,0) -- (1,0,0) -- (1,0,1) -- (0,0,1) -- cycle ;

  % text
\node (N0) at (0, 0.5, 0.5) {$N_0 @ z$};
    \node (N1) at (1, 0.5, 0.5) {$N_1 @ z$};
    \node (M) at (0.5, 0, 0.5) {$M @ z$} ;
\end{tikzpicture}
\end{minipage}
\end{center}
It suffices to do the composition on the unquoted lines and then quote the result:
\begin{align*}
    \hcom_{\Path[z.A](P_0; P_1)}^{r \leadsto r'}\hcomr \mapsto \langle z. \; \hcom_A (M @ z;\;&z=0 \hookrightarrow \_. \; P_0, \\
    &z=1 \hookrightarrow \_. \; P_1, \\
    &\xi_i \hookrightarrow y. \; N_i @ z) \rangle
\end{align*}

\section{The lay of the land}
So far, we have looked at cubical types: We saw how they must behave in different dimensions and that they furthermore have to satisfy the Kan conditions (coercion and composition).
Now, we would like to look at the multiverse of types\footnote{The multiverse cannot by a type, as the contrary would give rise to Russel's paradox.}, which itself has a cubical structure.
In particular, the multiverse has a form of Kan composition: if $A$ and $B_i$ are cubes of types, $\mathsf{HCOM}_{\mathit{(multiverse)}}^{r \leadsto r'} (A; \overrightarrow{\xi_i \hookrightarrow y.\;B_i})$ is itself a cube of types.

Considered at dimension~0, this gives us our usual types. But even at higher dimensions, the $\mathsf{HCOM}$'s can be given a Kan type structure by defining appropriate $\coe_{x. \mathsf{HCOM}}^{r \leadsto r'}(A)$ and $\hcom_{\mathsf{HCOM}}^{r \mapsto r'}(H; \overrightarrow{\xi_i \hookrightarrow y. \; H_i})$.
Especially the composition of compositions is challenging.
While we will not present the solution here, the key idea is to introduce constraints $\xi_i$ of the shape $y = y'$, representing diagonals.
Whereas part~II of the Computational Higher Type Theory papers \citep{Angiuli:chtt2:16} did not yet incorporate these constraints, they appear in part~III \citep{Angiuli:chtt3:17}.

Note that dimensions in the multiverse are not related to the indexing of universes in HoTT ($\mathcal{U}_0 \subseteq \mathcal{U}_1 \subseteq \dots$).
We can choose our multiverse to contain the entire hierarchy of universes at dimension~0, but this is not essential for our considerations and we could choose differently.

\section{Univalence}
We would like to incorporate univalence into our type theory, obviously without giving up its computational meaning.
We do so by populating the higher-dimensional structure of the multiverse with lines that correspond to (or: are given by) equivalences.

%In our type theory, we have a notion of
%\begin{itemize}
%    \item exactly equal types $\itype{A \doteq A'}\ps$ (equal ``elements'' of the multiverse, but not really elements because the multiverse is not a type),
%    \item lines between cubes \emph{within} a type and, since the last section, lines between cubes within the multiverse.
%\end{itemize}

\subsection{Equivalences}
Recall the definition of an equivalence from Week~11:
\begin{definition}[Equivalences]
    Let $A$ and $B$ be types.
    The equivalences between $A$ and $B$ are functions from $A$ to $B$ whose fibers are contractible:
    \[ \mathsf{Equiv}(A, B) \coloneqq (f : A \to B) \times (b : B \to \mathsf{isContractible}(f^{-1}(b))), \]
    where $f^{-1}(b)$ is short for $a : A \times \Path_{B}(f(a), b)$ and
    \[ \mathsf{isContractible(C) \coloneqq c : C \times (c' : C \to \Path(c, c'))}. \]
\end{definition}

\subsection{V-types}
Let $\itype{A}\;[\Psi \mid r = 0]$ (``a valid type on the left''), $\itype{B}\ps$ (``valid throughout'') and $E \in \mathsf{Equiv}(A, B)\;[\Psi \mid r = 0]$.
Then, we introduce
\[ \itype{V_r(A, B, E)}\ps. \]

This V-type completes the following diagram:
\begin{center}
\begin{tikzpicture}[>=stealth',node distance=2]
\node (a) {$A_0$};
\node (b0) [below=of a] {$B_0$};
\draw [->] (a) edge node [midway,left] {$E$} (b0);
\draw[transparent] (a) edge node[below,rotate=90,opacity=1] {$\sim$} (b0);
\node (b1) [right=of b0] {$B_1$};
\draw (b0) -- (b1) node [midway,above] {$B_x$};
\draw [dashed] (a) edge node [above right] {$V_x(A, B, E)$} (b1);
\end{tikzpicture}
\end{center}
Note that $V_x(A, B, E)$ is a line of types.
Let us see how the V-type is evaluated:
\[ V_0(A_0, \_, \_) \mapsto A_0 \qquad V_1(\_, B_1, \_) \mapsto B_1 \]
In particular,
\[ V_x(A_x, B_x, E_x)\langle 0 / x \rangle = V_0(A_0, \_, \_) \mapsto A_0 \qquad V_x(A_x, B_x, E_x)\langle 1 / x \rangle \mapsto B_1. \]

How does this relate to univalence? Consider the case where $B$ is a degeneracy.
Then, $V_x(A, B, E)$ packages $E$ composed with reflexivity, thus the equivalence, as a line.
This line allows us to coerce based on the equivalence.
But the V-type does even more: It converts lines!

What are the elements of the $V_r$'s?
If $M \in A\;[\Psi \mid r = 0]$ and $\fst(E)(M) \doteq N \in B \; [\Psi \mid r = 0]$, then
\[ \mathsf{Vin}_r(M, N) \in V_r(A, B, E) .\]
\begin{center}
    \begin{tikzpicture}[>=stealth',node distance=2]
\node (a) {$A_0$};
\node (b0) [below=of a] {$B_0$};
\draw [->] (a) edge node [midway,left] {$E$} (b0);
\draw[transparent] (a) edge node[below,rotate=90,opacity=1] {$\sim$} (b0);
\node (b1) [right=of b0] {$B_1$};
\draw (b0) -- (b1) node [midway,above] {$B_x$};
\draw [dashed] (a) edge node [above right] {$V_r(A, B, E)$} (b1);

\node (m) at (-5, 0){$M_0$};
\node (n0) [below=of m] {$N_0$};
\draw [|->] (m) edge node [midway,left] {$\fst(E)$} (n0);
\node (n1) [right=of n0] {$N_1$};
\draw (n0) -- (n1) node [midway,above] {$N_x$};
\draw [dashed] (m) edge node [above right] {$\mathsf{Vin}_x(M, N)$} (n1);
\end{tikzpicture}
\end{center}
Correspondingly,
\[ \mathsf{Vin}_0(M, N) \mapsto M \qquad \mathsf{Vin}_1(M, N) \mapsto N.\]

When $V \in V_r(A, B, E)$ and $F$ represents the equivalence (``$\fst(E)$''), the elimination form $\mathsf{Vproj}(V, F)$ recovers $N$.

Coercion along $V_x(A, B, E))$ from $0$ to $1$ can easily be implemented by applying the equivalence, then coercing along $B$.
Coercing from $1$ to $0$ is a little trickier since it involves some fiddling to reverse $E$.
Coercions of the form $\coe_{x.V_x}^{y \leadsto r'}(--)$ are very tricky and involve diagonal constraints.

While we do not have time to cover it, composition is particularly interesting and elegant.

\section{Hacking with cubical types}
There are three implementations of cubical type theory that one might want to experiment with:
\begin{description}
    \item[cubicaltt:] Focuses on evaluation, developed in Sweden. \url{https://github.com/mortberg/cubicaltt}.
    \item[yacctt:] Focuses on evaluation.
    \item[redprl:] An interactive proof editor in the tradition of Nuprl, developed at CMU. \url{http://www.redprl.org/}, \url{https://github.com/RedPRL/sml-redprl}.
\end{description}

\bibliographystyle{plainnat} \bibliography{ctt}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
