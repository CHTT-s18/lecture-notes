\documentclass{article}
\usepackage{chtt-notes}
\scribes{Evan Cavallo}
\week{7}
% The following command will let you cross-reference labels
% in the files week1.tex, week2.tex, \ldots, week\@week.tex,
% where if l is a label in ``weekN.tex'', then you can access
% the label using \cref{WN:l}.
\doXRs

% General remark: Using \cref{label} will fill in the appropriate
% environment name. For example,
% ``\begin{lemma}\label{lem:foo} ...\end{lemma} By \cref{lem:foo}''
% will produce ``Lemma 15 ... By lemma~15''


\newcommand{\Idsym}[4]{\mathsf{sym}_{#1}(#2;#3;#4)}
\newcommand{\Idtrans}[6]{\mathsf{trans}_{#1}(#2;#3;#4;#5;#6)}

\begin{document}
\maketitle

\section{Setting the Scene}

Last week, we introduced intensional (dependent) type theory (ITT), a formal
type theory which adds type-indexed families of types (or \emph{dependent
  types}) and corresponding type formers. This type theory is defined by way of
four inductively defined judgments.

\begin{center}
\begin{tabular}{ll}
  \hasTF{\Gamma}{A} &\text{$A$ is a type in context $\Gamma$.} \\
  \hasTEF{\Gamma}{A}{A'} &\text{$A$ and $A'$ are equivalent types in context $\Gamma$.} \\
  \hasEF{\Gamma}{M}{A} &\text{$M$ has type $A$ in context $\Gamma$.} \\
  \hasEEF{\Gamma}{M}{M'}{A} &\text{$M$ and $M'$ are equal elements of $A$ in context $\Gamma$.}
\end{tabular}
\end{center}

These judgments satisfy structural properties (weakening, contraction, and
exchange), which can either be proven by analyzing the inductive definition or
added by axiomatic fiat. Definitional equivalence is a very fine form of
``equality'', generated by reflexivity, symmetry, transitivity, compatibility
with the operations of the type theory, and simplification equations arising
from Gentzen's inversion principle. We defined three type formers for ITT:
$\Sigma$ (dependent sum/product) types, $\Pi$ (dependent product/function)
types, and identity types.\footnote{TODO ``dependent product''}

This week, we continue to examine the properties of the identity types
$\Id{A}{M}{N}$, which internalize a notion of equality between elements $M$ and
$N$ of a type $A$. In particular, we want to bring out certain unsatisfactory
properties of such a notion. We will then move to consider a
\emph{computational} dependent type theory defined by behavioral judgments
$\hasTEC{\Gamma}{A}{A'}$ and $\hasEEC{\Gamma}{M}{M'}{A}$, in which we have (and
can internalize) a behavioral notion of equality of and within types.

\section{Identity types and definitional equivalence}

Let us recall quickly recall (some of) the rules defining identity types.
\begin{mathpar}
  \inferrule[(F)]
  {\hasTF{\Gamma}{A} \\
    \hasEF{\Gamma}{M}{A} \\
    \hasEF{\Gamma}{N}{A}}
  {\hasTF{\Gamma}{\Id{A}{M}{N}}}
  \and
  \inferrule[(I)]
  {\hasEF{\Gamma}{M}{A}}
  {\hasEF{\Gamma}{\refl[A]{M}}{\Id{A}{M}{M}}}
  \and
  \inferrule[(E)]
  {\hasTF{\Gamma, a:A, b:A, p:\Id{A}{a}{b}}{C} \\
    \hasEF{\Gamma, a:A}{Q}{\subst{a,a,\refl[A]{a}}{a,b,p}{C}} \\
    \hasEF{\Gamma}{P}{\Id{A}{M}{N}}}
  {\hasEF{\Gamma}{\Idelim{a,b,p.C}{a.Q}{P}}{\subst{M,N,P}{a,b,p}{C}}}
  \and
  \inferrule[($\beta$)]
  {\hasTF{\Gamma, a:A, b:A, c:\Id{A}{a}{b}}{C} \\
    \hasEF{\Gamma, a:A}{Q}{\subst{a,a,\refl[A]{a}}{a,b,c}{C}} \\
    \hasEF{\Gamma}{M}{A}}
  {\hasEEF{\Gamma}{\Idelim{a,b,c.C}{a.Q}{\refl[A]{M}}}{\subst{M}{a}{Q}}{\subst{M,N,P}{a,b,c}{C}}}
\end{mathpar}

The introduction form $\refl[A]{M}$ can be thought of as expressing that
$\Id{A}{-}{-}$ is a reflexive ``relation:'' for any $M:A$, we have an element of
$\Id{A}{M}{M}$. The eliminator then expresses that $\Id{A}{-}{-}$ is the
\emph{least} reflexive relation: to define a map out of the family
$\Id{A}{-}{-}$ into a family $a.b.p.C$ (the \emph{motive}), it suffices to
consider the reflexive cases. As we suggested last week, this fact can be used
to establish that $\Id{A}{-}{-}$ is also symmetric and transitive, making it an
equivalence relation on elements of $A$. We'll start by proving these facts, so
we can get a feel for working with the identity type. For readability, we will
now write the type $\Id{A}{M}{N}$ as $\Ideq{A}{M}{N}$.

\begin{lemma}
  For all $\hasEF{\Gamma}{P}{\Ideq{A}{M}{N}}$, there exists a term
  $\hasEF{\Gamma}{\Idsym{A}{M}{N}{P}}{\Ideq{A}{N}{M}}$.
\end{lemma}
\begin{proof}
  We are defining a map out of the identity type $\Ideq{A}{M}{N}$ into
  $\Ideq{A}{N}{M}$. As such, we will want to use the identity eliminator. The
  eliminator requires us to think in terms of the \emph{family} of all identity
  types in $A$: given \emph{any} $a,b : A$ and a term $p : \Ideq{A}{a}{b}$, what
  type $C(a,b,p)$ to we want to inhabit? In this case, it seems sensible to take
  $C(a,b,p) \eqdef \Ideq{A}{b}{a}$. The elimination principle says that to inhabit
  $C(a,b,p)$ in general, it suffices to inhabit the reflexive case
  $C(a,a,\refl[A]{a})$ given $a : A$. We have
  $C(a,a,\refl[A]{a}) = \Ideq{A}{a}{a}$, so we can inhabit this type with
  $\refl[A]{a}$. Returning to our original objective, the eliminator now gives
  us an element of $C(M,N,P)$, that is, $\Ideq{A}{N}{M}$.  Written out in full,
  this element is
  \[
    \Idsym{A}{M}{N}{P} \eqdef
    \Idelim{a.b.p.\Ideq{A}{b}{a}}{a.\refl[A]{a}}{P}. \qedhere
  \]
\end{proof}

Let us reflect for a moment on the term we have defined to implement
symmetry. By the $\beta$ rule for the eliminator, we have
$\hasEEF{\Idsym{A}{M}{M}{\refl[A]{M}}}{\refl[A]{M}}{\Ideq{A}{M}{M}}$; if we put
a reflexivity in, we get a reflexivity out. This is a definitional equivalence,
which we can internalize to inhabit the corresponding identity type:
\[
 \hasEF{\refl[\Ideq{A}{M}{M}]{\refl[A]{M}}}{\Ideq{\Ideq{A}{M}{M}}{\Idsym{A}{M}{M}{\refl[A]{M}}}{\refl[A]{M}}}.
\]

\begin{lemma}
  For every $\hasEF{\Gamma}{P}{\Ideq{A}{M}{N}}$ and
  $\hasEF{\Gamma}{Q}{\Ideq{A}{N}{O}}$, there exists a term
  $\hasEF{\Gamma}{\Idtrans{A}{M}{N}{O}{P}{Q}}{\Ideq{A}{M}{O}}$.
\end{lemma}
\begin{proof}
  Once again, we are defining a map out of the identity type, so we will have to
  use the eliminator. In this case, we have a choice: we can start by applying
  the eliminator either with $P$ or with $Q$. Let's try the former. As before,
  we have to generalize to the family of identity types: given $a,b : A$ and
  $p : \Ideq{A}{a}{b}$, what is the type $C(a,b,p)$ we want to inhabit? Here, the
  answer is a bit less obvious. One option is to take
  \[
    C(a,b,p) \eqdef \Pitype{c}{C}{\Ideq{A}{b}{c} \to \Ideq{A}{a}{c}}.
  \]
  We think of $C(a,b,p)$ as the type of functions which extend any
  $q : \Ideq{A}{b}{c}$ by our identification $p : \Ideq{A}{a}{b}$, returning an
  identification $\Ideq{A}{a}{c}$.

  To use the eliminator, we have to supply the reflexivity case
  $C(a,a,\refl[A]{a})$. Expanding the definition of $C$, we need a function
  $\Pitype{c}{C}{\Ideq{A}{a}{c} \to \Ideq{A}{a}{c}}$. For this, we can take the
  identity function $\lam{c}{C}{\lam{q}{\Ideq{A}{a}{c}}{q}}$.

  Applying the eliminator we have described to the identification $P$ gives us
  the term
  \[
    \hasEF{\Idelim{a.b.p.\Pitype{c}{C}{\Ideq{A}{b}{c} \to \Ideq{A}{a}{c}}}{a.\lam{c}{C}{\lam{q}{\Ideq{A}{a}{c}}{q}}}{P}}{\Pitype{c}{C}{\Ideq{A}{N}{c} \to \Ideq{A}{M}{c}}}.
  \]
  We can take $\Idtrans{A}{M}{N}{O}{P}{Q}$ to be the result of applying this
  function at $O$ and $Q$.
\end{proof}

Once again, let's take a look at the definitional equivalences satisfied by the
transitivity term. By the $\beta$ rule for the eliminator, we have
\[
  \Idtrans{A}{M}{M}{N}{\refl[A]{M}}{Q} \equiv
  (\lam{c}{C}{\lam{q}{\Ideq{A}{a}{c}}{q}})(N)(Q) \equiv
  Q.
\]
On the other hand, we \emph{don't} have an equivalence
$\Idtrans{A}{M}{N}{N}{P}{\refl[A]{N}} \equiv P$ in general! This is because we
defined the transitivity term by eliminating with $P$; if we had used $Q$, the
situation would be reversed. Here we see another example of the finicky nature
of definitional equivalence. On the other hand, one can (exercise!) inhabit the
identity type
\[
  \Ideq{\Ideq{A}{M}{N}}{\Idtrans{A}{M}{N}{N}{P}{\refl[A]{N}}}{P}.
\]
Thus, the identity type provides a notion of equality strictly weaker than
definitional equivalence. We might wonder whether it can rightly be called a
notion of equality at all: at the moment, we only know it is an equivalence
relation. One encouraging property is Leibniz's principle of
\emph{indiscernibility of identicals}: any terms related by an identification
have the same properties.

\begin{theorem}[Indiscernibility of identicals]
  Let $\hasEF{\Gamma}{P}{\Ideq{A}{M}{N}}$. For any $\hasTF{\Gamma,a:A}{B}$,
  there is a function
  $\hasEF{\Gamma}{\transport{a.B}}{\subst{M}{a}{B} \to \subst{N}{a}{B}}$.
\end{theorem}
\begin{proof}
  Define
  $\transport{a.B} \eqdef \Idelim{b.c.p.\subst{b}{a}{B} \to \subst{c}{a}{B}}{a.\lam{d}{B}{d}}{P}$.
\end{proof}

When we read the family $B$ as a predicate (i.e., family of propositions), the
type of $\transport{a.B}$ says that the property $\subst{M}{a}{B}$ implies
$\subst{N}{a}{B}$. If we apply the theorem again with $\Idsym{M}{N}{P}$, we find
that $\subst{N}{a}{B}$ likewise implies $\subst{M}{a}{B}$. So $\subst{M}{a}{B}$
and $\subst{N}{a}{B}$ are logically equivalent: $M$ satisfies $B$ if and only if
$N$ satisfies $B$. As this is true for all $B$, we can say that $M$ and $N$
satisfy the same predicates.

Sadly, our high hopes for the identity type are dashed when we examine identity
at function type. As an example, consider the function
$\lam{b}{\bool}{\ifexprtyp{\_.\bool}{b}{\true}{\false}}$. As we have already
discovered, this function is not definitionally equivalent to the identity
function. However, we can construct an identification
\[
  \hasEF{b:\bool}{\ifexprtyp{b.\Ideq{\bool}{\ifexprtyp{\_.\bool}{b}{\true}{\false}}{b}}{b}{\refl[\bool]{\true}}{\refl[\bool]{\false}}}{\Ideq{\bool}{\ifexprtyp{\_.\bool}{b}{\true}{\false}}{b}}
\]
by cases on the form of $b$. So far, this looks great: we can use the identity
type to establish ``equalities'' which require non-trivial reasoning, something
we couldn't do with definitional equivalence. But suppose we now want to inhabit
the type
\[
  \hasTF{\cdot}{\Ideq{\bool\to\bool}{(\lam{b}{\bool}{\ifexprtyp{\_.\bool}{b}{\true}{\false}})}{(\lam{b}{\bool}{b})}}.
\]
It turns out that this is impossible! This fact follows from a theorem of
\citet[Theorem 3.14]{MartinLof:73}, which characterizes the inhabitants of
closed identity types.

\begin{theorem}[Martin-L\"of]
  \label{thm:closed-id-is-definitional}
  $\hasTF{\cdot}{\Id{A}{M}{N}}$ is inhabited if and only if
  $\hasEEF{\cdot}{M}{N}{A}$.
\end{theorem}

This theorem is a corollary of a normalization result: if $P$ is a closed term
inhabiting $\Id{A}{M}{N}$, then $P$ reduces to a canonical value in
$\Id{A}{M}{N}$. As the only canonical values in $\Id{A}{M}{N}$ are the
reflexivity terms, $\Id{A}{M}{N}$ can only be inhabited if it is inhabited by
some $\refl[A]{O}$, which in turn is only possible when
$\hasEEF{\cdot}{M}{N}{A}$.

Thus, unlike definitional equivalence, the identity type is not compatible with
$\lambda$-abstraction. We say that intensional type theory lacks \emph{function
  extensionality}, meaning more specifically that the rule
\begin{mathpar}
  \inferrule[(Funext)]
  {\trueF{\Gamma}{\Pitype{a}{A}{\Id{B}{Fa}{Ga}}}}
  {\trueF{\Gamma}{\Id{\Pitype{a}{A}{B}}{F}{G}}}
\end{mathpar}
is not admissible.  We call this \emph{extensionality} because it expresses that
a function is characterized by its \emph{extension}, that is, its behavior on
arguments. In intensional type theory, functions with different
\emph{intension}, i.e., differing syntactic definitions, may not be identifiable
even if their extensions are equal. 

\section{Pursuing function extensionality}

The lack of function extensionality is quite a blow for intensional type theory,
as it prevents us from working with functions in any way resembling traditional
mathematics. As such, there are a number of approaches for recovering a form of
extensionality.

\paragraph{Go Straight to Setoid Hell} If we want to endow $\Pitype{a}{A}{B}$
with the ``correct'' notion of equality, one option is to toss the identity type
aside and instead manually define the equality relations we want. Instead of
working with types, we can instead work (still inside ITT) using types
$\hasTF{\Gamma}{A}$ paired with equivalence relations
$\hasTF{\Gamma, a:A, a':A}{R}$. These pairs are called \emph{setoids}. Given
setoids $(A,a.a'.R)$ and $(B,b.b'.S)$, for example, we would define their
function setoid as having carrier $A \to B$ and equivalence relation
\[
  \hasTF{f:A \to B, f':A \to B}{\Pitype{a}{A}{\Pitype{a'}{A}{R(a,a') \to S(f(a),f'(a'))}}}.
\]
With this relation serving as equality for $A \to B$, we recover
extensionality. Unfortunately, passing equivalence relations around for every
type quickly becomes prohibitively bureaucratic, as one must check explicitly
that every function one defines preserves equivalence.

\paragraph{Extensional Type Theory}

We know that definitional equivalence is compatible with $\lambda$-abstraction,
so we might view the problem as the distance between definitional equivalence
and identity types. We can try closing this gap by adding an \emph{equality
  reflection} rule.
\begin{mathpar}
  \inferrule
  {\hasEF{\Gamma}{P}{\Id{A}{M}{N}}}
  {\hasEEF{\Gamma}{M}{N}{A}}
\end{mathpar}
This rule allows us to transform any inhabited identity type into a definitional
equivalence. It is usually accompanied by a rule expressing \emph{uniqueness of
  identity proofs}, which states that there is at most one inhabitant of a given
identity type.
\begin{mathpar}
  \inferrule
  {\hasEF{\Gamma}{P}{\Id{A}{M}{N}} \\
    \hasEF{\Gamma}{Q}{\Id{A}{M}{N}}}
  {\hasEEF{\Gamma}{P}{Q}{\Id{A}{M}{N}}}
\end{mathpar}
The resulting system is often called \emph{extensional type theory} (ETT). Note
that these rules are already admissible in ITT when $\Gamma = \cdot$ by
\cref{thm:closed-id-is-definitional}, so their addition does not disrupt the
computational interpretation of closed terms. By unifying definitional
equivalence with identity types, we get the desirable properties of both:
compatibility with $\lambda$-abstraction and the ability to establish
equivalence which require non-trivial reasoning.\footnote{To get function
  extensionality, we also need an $\eta$ rule stating that
  $\hasEEF{\Gamma}{F}{\lam{a}{A}{Fa}}{\Pitype{a}{A}{B}}$ for any
  $\hasEF{\Gamma}{F}{\Pitype{a}{A}{B}}$.}  However, the latter can also be seen
as a weakness: it means that the definitional equivalence judgment
$\hasEEF{\Gamma}{M}{N}{A}$, and thereby every judgment of the type theory,
ceases to be decidable. Terms thus become distinct from derivations: a
well-typed term no longer contains all the information necessary to recover its
typing derivation, as proofs of identity are forgotten in equality reflection.

\paragraph{New Identity Axioms}

Finally, we can simply assert function extensionality as a new rule.
\begin{mathpar}
  \inferrule
  {\hasEF{\Gamma}{P}{\Pitype{a}{A}{\Id{B}{Fa}{Ga}}}}
  {\hasEF{\Gamma}{\funext{A}{B}{F}{G}{P}}{\Id{\Pitype{a}{A}{B}}{F}{G}}}
\end{mathpar}
Unlike in ETT, we are adding identifications rather than definitional
equivalences, so there is no effect on the decidability of typing judgments. In
this case, however, we disrupt the computation system: we have no way of
reducing a term like
\[
  \Idelim{a.b.p.C}{a.Q}{\funext{A}{B}{F}{G}{P}}.
\]
In essence, we have added a new canonical form to the identity type without
providing a corresponding reduction rule for the eliminator. There do exist
solutions to this problem: see the \emph{observational type theory} of
\cite{Altenkirch:07}.

Homotopy type theory \citep{HoTTBook:13} obtains function extensionality by
adding the stronger \emph{univalence axiom}, which provides a form of
extensionality for elements of a universe (a type of types). Roughly speaking,
univalence states that identities between types in the universe correspond to
isomorphisms between those types. Surprisingly, the univalence axiom implies
function extensionality for function types formed from types in the
universe. However, homotopy type theory suffers from a lack of computational
interpretation for the same reason: there is no way to evaluate the identity
eliminator on an identification created by univalence. Only recently have
variants of HoTT with computational interpretations arrived
\citep{Cohen:16,Angiuli:chtt3:17}; we will discuss these in future weeks.

\section{Computational dependent type theory}

Now that we have the formal system of ITT in hand, we would like to bring out
its computational properties. Informally, we want to show that we can read
computational objects from well-typed terms, and that these terms can be
evaluated to obtain some result. There are thus two components to the
computational interpretation, much as in the non-dependent case:

\begin{description}
\item[Erasure.] The terms of ITT are full of annotations which have no relevance
  to computation, such as the $A$ in $\refl[A]{M}$ or $\lam{a}{A}{N}$. (We have
  already suppressed many of these annotations---$\lam{a}{A}{N}$ should really
  be annotated with the target family $a.B$, for example.) Moreover, certain
  operations like identity elimination have no computational content at all. We
  therefore want an \emph{erasure} or \emph{extraction} operation $\erase{-}$,
  which extracts the part of a term which is actually relevant to computation.
\item[Operational semantics.] Next, we need to describe the process by which we
  execute terms. We can encode this as a deterministic \emph{structural
    operational semantics} on closed erased terms, specified by judgments
  $\step{M}{M'}$ and $\valueJ{M}$.
\end{description}

We also want to relate this interpretation of terms to the types of ITT,
interpreting the type of a term as a specification of its erasure's execution
behavior. This semantics is called a \emph{meaning explanation} of the types,
following \cite{MartinLof:79}, and corresponds to the hereditary termination and
equality predicates we have previously defined. The meaning explanation takes
the form of semantic equivalents of each formal judgment:
\begin{center}
\begin{tabular}{cccc}
  \hasTC{\Gamma}{A}, &
  \hasTEC{\Gamma}{A}{A'}, &
  \hasEC{\Gamma}{M}{A}, &
  \hasEEC{\Gamma}{M}{M'}{A}.
\end{tabular}
\end{center}
In the non-dependent case, the equivalent of the judgment $\hasEC{\Gamma}{M}{A}$
was defined as
$\forall \gamma. \hterm{\Gamma}{\gamma} \supset
\hterm{A}{\hat\gamma\erase{M}}$. In the dependent case, terms can appear in
types, so types themselves must be endowed with an extraction operation and an
operational semantics. Erased types, then, are simply particular terms, namely
those which evaluate to a code for a specification. These include programs like
$\bool$ and $\bool \to \bool$, which are already values, but also programs like
$\ifexpr{\true}{\bool}{\nat}$, which evaluates to the specification
$\bool$. Note that the ``small'' and ``large'' eliminators of the formal theory
can be erased to the same operator.

We are thus led to the following rough reading of the closed semantic
judgments.
\begin{center}
\begin{tabular}{ll}
  \hasTC{A} &\text{$A$ is a well-behaved program evaluating to a canonical type.} \\
  \hasTEC{A}{A'} &\text{$A$ and $A'$ evaluate to equivalent canonical types.} \\
  \hasEC{M}{A} &\text{$A$ evaluates to a canonical type, and $M$ evaluates to a canonical} \\
               &\text{value of that canonical type.} \\
  \hasEEC{M}{M'}{A} &\text{$A$ evaluates to a canonical type, and $M$ and $M'$ to equivalent} \\
                    &\text{canonical values of that canonical type.}
\end{tabular}
\end{center}

The basis of a meaning explanation for a type theory is thus the definition of
its canonical types and the canonical values of said types. We will regard
$\hasTC{A}$ and $\hasEC{M}{A}$ as being derived from the other two judgments,
with $\hasTC{A}$ meaning $\hasTEC{A}{A'}$ and $\hasEC{M}{A}$ meaning
$\hasEEC{M}{M}{A}$. The open judgment forms, $\hasTEC{\Gamma}{A}{A'}$ and
$\hasEEC{\Gamma}{M}{M'}{A}$, are defined from the closed judgments by
\emph{functionality}: equal open terms are those which take equal closing
substitutions to equal closed terms. As an example, we will define the open
judgments for the case of a one-element context.

\begin{definition}~
  \begin{itemize}
  \item The judgment $\hasTEC{a:A}{B}{B'}$ holds when for all
    $\hasEEC{M}{M'}{A}$, we have $\hasTEC{\subst{M}{a}{B}}{\subst{M'}{a}{B'}}$.
  \item The judgment $\hasEEC{a:A}{N}{N'}{B}$ holds when for all
    $\hasEEC{M}{M'}{A}$, we have
    $\hasEEC{\subst{M}{a}{N}}{\subst{M'}{a}{N'}}{\subst{M}{a}{B}}$.
  \end{itemize}
\end{definition}
The general judgments $\hasTEC{\Gamma}{A}{A'}$ and $\hasEEC{\Gamma}{M}{M'}{A}$
are defined in this fashion by induction on the length of the context
$\Gamma$. (For a complete definition of this iterated functionality, see for
example \cite{MartinLof:79}.)

The last step to giving a full meaning explanation for type theory is to explain
the equal canonical types and the equal canonical values in each type. As an
example, we add booleans to the type theory as follows.

\begin{enumerate}
\item $\bool$ and $\bool$ are equal canonical types.
\item $\true$ and $\true$ are canonical values satisfying the specification $\bool$.
\item $\false$ and $\false$ are canonical values satisfying the specification $\bool$.
\item No other values satisfy $\bool$. In other words, $\bool$ is inductively
  generated by the previous two clauses. 
\end{enumerate}

From these, it follows trivially that $\hasTC{\bool}$, $\hasEC{\true}{\bool}$,
and $\hasEC{\false}{\bool}$. But these are not the only facts which follow from
this definition: we also get the elimination rule.

\begin{theorem}
  If
  \begin{enumerate}
  \item $\hasTC{b:\bool}{A}$, 
  \item $\hasEEC{M}{M'}{\bool}$, 
  \item $\hasEEC{N}{N'}{\subst{\true}{b}{A}}$, and
  \item $\hasEEC{P}{P'}{\subst{\false}{b}{A}}$,
  \end{enumerate}
  then $\hasEEC{\ifexpr{M}{N}{P}}{\ifexpr{M'}{N'}{P'}}{\subst{M}{b}{A}}$.
\end{theorem}

This theorem follows by an analysis of the operational behavior of the
conditional terms, using what $\hasEEC{M}{M'}{\bool}$ tells us about the
behavior of $M$ and $M'$.

Next week, we will prove this theorem, and continue on to translate the other
types of ITT into the computational setting. As an equivalent of the identity
type, we will introduce an \emph{equality} type $\Eq{A}{M}{M'}$, which
internalizes the equality judgment $\hasEEC{M}{M'}{A}$. We will interpret the
formal $\Id{A}{M}{M'}$ type using this equality type, erasing the
computationally trivial identity eliminator in the process.

\bibliographystyle{plainnat}
\bibliography{ctt}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
